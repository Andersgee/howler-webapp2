datasource db {
    provider = "mysql"
    url      = env("DATABASE_MYSQL_URL")
}

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["fullTextIndex"]
}

model CloudMessageAccessToken {
    id      BigInt   @db.UnsignedBigInt
    token   String   @db.VarChar(2000) //it seems to be 1024 long
    expires DateTime @db.DateTime(3)

    @@id([id])
}

model DeletedEventImages {
    image String @db.VarChar(100)

    @@id([image])
}

model Event {
    id            BigInt                @default(autoincrement()) @db.UnsignedBigInt
    createdAt     DateTime              @default(now()) @db.DateTime(3)
    updatedAt     DateTime              @default(now()) @updatedAt @db.DateTime(3)
    title         String                @db.VarChar(55)
    date          DateTime              @default(now()) @db.DateTime(3)
    location      Unsupported("point")? //https://dev.mysql.com/doc/refman/8.0/en/spatial-type-overview.html
    locationName  String?               @db.VarChar(55)
    creatorId     BigInt                @db.UnsignedBigInt
    image         String?               @db.VarChar(100)
    imageBlurData Bytes?                @db.VarBinary(255) //4x4=16 pixels ends up around 127 bytes, so go with 255 (btw, dont do tinyblob here. presence of blobs hurt read speed, but necessary for Large OBjects)
    imageAspect   Float                 @default(1) @db.Float

    Event_creatorId_fkey        User             @relation("Event_creatorId_fkey", fields: [creatorId], references: [id], onUpdate: Cascade, onDelete: Cascade)
    UserEventPivot_eventId_fkey UserEventPivot[] @relation("UserEventPivot_eventId_fkey")

    @@id([id])
    @@index([creatorId])
    @@fulltext([title, locationName])
}

model FcmToken {
    token  String @db.VarChar(200) //They seem to be 163 long but that might change? they used to be shorter.
    userId BigInt @db.UnsignedBigInt

    FcmToken_userId_fkey User @relation("FcmToken_userId_fkey", fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

    @@id([token])
    @@index([userId])
}

model Notification {
    id           BigInt   @default(autoincrement()) @db.UnsignedBigInt
    title        String   @db.VarChar(55)
    body         String   @db.VarChar(55)
    relativeLink String   @db.VarChar(55)
    createdAt    DateTime @default(now()) @db.DateTime(3)

    UserNotificationPivot_notificationId_fkey UserNotificationPivot[] @relation("UserNotificationPivot_notificationId_fkey")

    @@id([id])
}

model Post {
    id        BigInt   @default(autoincrement()) @db.UnsignedBigInt
    text      String
    createdAt DateTime @default(now()) @db.DateTime(3)
    updatedAt DateTime @default(now()) @updatedAt @db.DateTime(3)
    userId    BigInt   @db.UnsignedBigInt

    Post_userId_fkey User @relation("Post_userId_fkey", fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

    @@id([id])
    @@index([userId])
}

model User {
    id              BigInt         @default(autoincrement()) @db.UnsignedBigInt
    email           String //allow multiple sign in methods, but same email would be same user.
    googleUserSub   String?
    discordUserId   String?
    githubUserId    Int?
    image           String?
    name            String
    createdAt       DateTime       @default(now()) @db.DateTime(3)
    updatedAt       DateTime       @default(now()) @updatedAt @db.DateTime(3)
    role            User_role_enum @default(USER)
    facebookdUserId String?

    FcmToken_userId_fkey              FcmToken[]              @relation("FcmToken_userId_fkey")
    Post_userId_fkey                  Post[]                  @relation("Post_userId_fkey")
    Event_creatorId_fkey              Event[]                 @relation("Event_creatorId_fkey")
    UserUserPivot_userId_fkey         UserUserPivot[]         @relation("UserUserPivot_userId_fkey")
    UserUserPivot_followerId_fkey     UserUserPivot[]         @relation("UserUserPivot_followerId_fkey")
    UserNotificationPivot_userId_fkey UserNotificationPivot[] @relation("UserNotificationPivot_userId_fkey")
    UserEventPivot_userId_fkey        UserEventPivot[]        @relation("UserEventPivot_userId_fkey")

    @@id([id])
    @@unique([email])
    @@unique([googleUserSub])
    @@unique([discordUserId])
    @@unique([githubUserId])
    @@unique([facebookdUserId])
}

model UserEventPivot {
    userId   BigInt   @db.UnsignedBigInt
    eventId  BigInt   @db.UnsignedBigInt
    joinDate DateTime @default(now()) @db.DateTime(3)

    UserEventPivot_eventId_fkey Event @relation("UserEventPivot_eventId_fkey", fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
    UserEventPivot_userId_fkey  User  @relation("UserEventPivot_userId_fkey", fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

    @@id([eventId, userId])
    @@index([userId])
}

model UserNotificationPivot {
    userId         BigInt @db.UnsignedBigInt
    notificationId BigInt @db.UnsignedBigInt

    UserNotificationPivot_notificationId_fkey Notification @relation("UserNotificationPivot_notificationId_fkey", fields: [notificationId], references: [id], onUpdate: Cascade, onDelete: Cascade)
    UserNotificationPivot_userId_fkey         User         @relation("UserNotificationPivot_userId_fkey", fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

    //btw to change order of this. [notificationId,userID] to [userId, notificationId]
    //I had to go into mysql cli and remove foreign key constraints, eg
    //SHOW CREATE TABLE UserNotificationPivot;
    //ALTER TABLE UserNotificationPivot DROP FOREIGN KEY UserNotificationPivot_notificationId_fkey
    //ALTER TABLE UserNotificationPivot DROP FOREIGN KEY UserNotificationPivot_userId_fkey
    //only then was it allowed to push re-ordered primary key, which is DROP and then add
    // 
    // TLDR;
    // I wish prisma schema did not enforce an @@id field, since it indexes relations anyway
    // meaning a pivot like this already has a KEY on userId and a KEY on notificationId without adding on some extra PRIMARY KEY
    // and primary keys must be unique so must do compound key
    // 
    // another option is doing an autoincrement id and use that as primary key, would also allow sorting...

    @@id([userId, notificationId])
    @@index([notificationId]) //this will be here regardless
}

model UserUserPivot {
    userId     BigInt   @db.UnsignedBigInt
    followerId BigInt   @db.UnsignedBigInt
    createdAt  DateTime @default(now()) @db.DateTime(3)

    UserUserPivot_userId_fkey     User @relation("UserUserPivot_userId_fkey", fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
    UserUserPivot_followerId_fkey User @relation("UserUserPivot_followerId_fkey", fields: [followerId], references: [id], onUpdate: Cascade, onDelete: Cascade)

    @@id([userId, followerId])
    @@index([followerId])
}

enum User_role_enum {
    USER
    ADMIN
}
